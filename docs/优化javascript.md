## 如何写出优化的 JavaScript
1. 对象属性的顺序: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享。
2. 动态属性: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配。
3. 方法: 重复执行相同的方法会运行的比不同的方法只执行一次要快 (因为内联缓存)。
4. 数组: 避免使用 keys 不是递增的数字的稀疏数组，这种不是每一个元素在里面的稀疏数组其实是一个 hash 表。在这种数组中每一个元素的获取都是昂贵的代价。同时，要避免提前申请大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素，因为这会使得 keys 变得稀疏。
5. 标记值 (Tagged values): V8 用 32 位来表示对象和数字。它使用一位来区分它是对象 (flag = 1) 还是一个整型 (flag = 0)，也被叫做小整型(SMI)，因为它只有 31 位。然后，如果一个数值大于 31 位，V8 将会对其进行 box 操作，然后将其转换成 double 型，并且创建一个新的对象来装这个数。所以，为了避免代价很高的 box 操作，尽量使用 31 位的有符号数。

## javascript中常见的内存泄露
1. 未声明便使用变量(严格模式下会报错)。未声明的变量将会挂载到全局上，任何使用的到这个变量的地方都将不会被GC标记，导致GC不会清除相关的调用。如果需要使用全局变量时一定要手动的释放，x = null, x = undefined
2. 被忘记的定时器或者回调函数。在老旧浏览器中，添加的事件订阅器或者定时器，如果在不需要它们的时候不正确释放或移除，将导致变量被持续引用。现代浏览器能够正确移除不再使用的事件监听器(比如在为一个元素添加click事件时，如果该元素被删除了，浏览器将自动移除订阅他的事件)
3. 闭包。形成的闭包被外部引用，能够在外部访问闭包的内部，那么这个闭包将不会被GC正确清理
4. 超出DOM的引用。DOM树保持着对内部节点的引用，如果使用document的方法获取到了DOM元素，使得内存中有了这些节点的引用，那么即使DOM树删除了这些节点，GC也不能正确释放相关的资源